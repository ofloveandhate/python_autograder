
def deprecated_get_num_passes(filepath):
    """
    computes the number of passed tests by reading the top lines of the checker output,
    namely by counting the number of .'s

    this number will be incorrect if there's screenout in the middle of the string
    this can only be prevented by capturing all warnings and printing during all tests,
    which makes the test output significantly less useful.
    """
    with open(filepath,'r') as file:
        data = file.read()


    as_lines = data.split('\n')

    topline = as_lines.pop(0)

    while len(set(topline)-set('.EF'))>0:
        if 'Warning' in topline:
            as_lines.pop(0) # the next line is a follow-on to the warning we're skipping
            topline = as_lines.pop(0)
        else:
            topline = as_lines.pop(0)

    num_fails = len(topline) - topline.count('.')
    return topline.count('.'), topline





def deprecated_tests_to_feedback(filename):
    """
    feed this function a filename, read from a unittest file
    """
    with open(filename,'r') as file:
        raw_data = file.read()
        data = raw_data.split('\n')

    if 'Traceback' in data[0]:
        return "Your file has a critical error in it, such that the autograder was not able to execute your code, and thus was unable to run any tests:\n\n"+raw_data

    feedback = ''
    topline = data.pop(0)
    num_warnings = 0
    num_weird = 0

    found_warnings = ''
    found_weird = ''
    while len(set(topline)-set('.EF'))>0:

        if 'Warning' in topline:
            if num_warnings == 0:
                found_warnings = found_warnings+'### Detected warnings your code generated:'
            found_warnings = found_warnings+"\n\n===> Your code has a warning in it!!!  Don't ignore warnings!!!!\n\n"+topline+'\n'+data.pop(0)
            topline = data.pop(0)
            num_warnings = num_warnings+1
        else:
            if num_weird==0:
                found_weird=found_weird+'found some unexpected lines from the checker.'
            found_weird = found_weird+topline
            topline = data.pop(0)

    feedback = found_warnings + ("\n\n" if num_warnings>0 else "") + found_weird + ("\n\n" if num_weird>0 else "")
    num_fails = len(topline) - topline.count('.')

    encountered_fails = 0
    linenum=0
    while linenum < len(data):
        line = data[linenum]
        if line.startswith('FAIL: ') or line.startswith('ERROR: '):
            encountered_fails = encountered_fails+1

            #if encountered_fails==1:
            #   feedback = feedback+'### Autograder tests failed in this autochecker file:\n\n'
            d = line.split(' ')
            test_name = d[1]
            feedback = feedback+f'{encountered_fails}: {test_name}\n'
            linenum+=5
            feedback = feedback+f'\t --reason: failed {data[linenum]}\n\n'
        linenum+=1


    if encountered_fails!=num_fails:
        raise RuntimeError(f'mismatched number of not-passed tests, expected {num_fails}, found {encountered_fails}, in {filename}')
    return feedback

def deprecated_collect_num_passes_txt_format(path):
    """
    constructs a data frame, holding the number of passes, etc.
    scans all .txt files in the folder, which were presumably
    generated by running a checker against students' code.
    """

    name = []
    student_id = []
    file_number = []
    num_passes = []
    success_string = []
    feedback = []
    # canvas_name = []
    # section = []

    files = os.listdir(path)
    for f in files:
        if f.endswith('.txt'):
            d = process_filename(f)
            name.append(d['name'])
            student_id.append(int(d['student_id']))
            file_number.append(int(d['file_number']))
            q = deprecated_get_num_passes(join(path,f))
            num_passes.append(q[0])
            success_string.append(q[1])
            feedback.append(tests_to_feedback(join(path,f)))

    df = pd.DataFrame({'name':name, "student_id":student_id,
        "file_number":file_number, "num_passes":num_passes,
        "success_string":success_string, 'feedback':feedback})

    df['num_tests'] = df['success_string'].map(lambda x: len(x))
    df['percent_pass'] = df['num_passes']/df['num_tests']
    return df
